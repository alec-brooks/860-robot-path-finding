#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "config.h"
#include "compass.c"
#include "light_sensor.c"

#define LEFT false
#define RIGHT true

#define SONAR_THRESHOLD 20
#define ANGLE_THRESHOLD 30

#define FOUND_ERROR -1
#define FOUND_CAN 0
#define FOUND_NODE 1
#define FOUND_HOTEL 2
#define FOUND_LEAF 3

bool followingEdge = true;


bool DetectCan(void) {
 return false;
}

int CountNodeEdges(void) {
  return 0;
}

void displayBrightness(void) {
	string name;
	if(isGrey()) {
		name = "grey";
	} else if(isDark()) {
		name = "black";
	} else if(isLight()) {
		name = "white";
	}
	nxtDisplayCenteredTextLine(3, name);
 }

bool direction = LEFT;
void edgeFollow(bool& running){
	if(direction == LEFT) {
		motor[left] = -SPEED;
		motor[right] = SPEED;
	} else {
		motor[left] = SPEED;
		motor[right] = -SPEED;
	}
	bool wasDark = isDark();
	displayBrightness();
	do{
	  if(direction) {
		  nxtDisplayCenteredTextLine(2, "RIGHT");
		} else {
		  nxtDisplayCenteredTextLine(2, "LEFT");
		}
		//Find border point
		if(wasDark != isDark()) {
			displayBrightness();
			wasDark = isDark();
			wait10Msec(10);
			if(direction == LEFT) {
				direction = RIGHT;
				motor[left] = SPEED;
				motor[right] = 0;
			} else if( direction == RIGHT) {
				direction = LEFT;
				motor[right] = SPEED;
				motor[left] = 0;
			}
			abortTimeslice();
		}
	}while(running);
}

bool detectCan(void) {
	return SensorValue[sonar] < SONAR_THRESHOLD;
}

bool detectNode(int forwards) {
	return abs(angleDifference(currentDirection(), forwards)) > ANGLE_THRESHOLD;
}

int gatherForwardsData(void) {
	time100[T2] = 0;
	int timeToWait = minDistance*10/(2*mmPs);

	int count = 0;
	int forwards = 0;

	while(time100[T2] < timeToWait) {
		forwards = forwards + (angleDifference(currentDirection(), forwards))/++count;

		nxtDisplayCenteredTextLine(4, "%i", forwards);
		nxtDisplayCenteredTextLine(5, "%i", currentDirection());
		nxtDisplayCenteredTextLine(6, "%i", count);
		wait10Msec(20);
	}
	return forwards;
}

task FollowEdge(){
	followingEdge = true;
	edgeFollow(followingEdge);
}

bool checkIsLeaf(void) {
	int direction = currentDirection();
	while(!isDark()) {
		if( abs(angleDifference(currentDirection(), direction)) > 170) {
			return true;
		}
	}
	return false;
}

/**
 * Turns around until black is found
 */
void turnAround(void) {
  if(direction == LEFT) {
		motor[left] = -SPEED;
		motor[right] = SPEED;
	} else {
		motor[left] = SPEED;
		motor[right] = -SPEED;
	}
	while(!isDark()) {
		abortTimeslice();
	}

}

int FollowLineTilLeaf(void) {
	StartTask(FollowEdge);
	int forwards = gatherForwardsData();
	for(;;) {
		if(detectNode(forwards)) {
			if(checkIsLeaf()) {
				followingEdge = false;
				StopTask(FollowEdge);
				return FOUND_LEAF;
			} else {
				forwards = gatherForwardsData();
			}
		}
		abortTimeslice();
	}
}

int FollowLineTilHotel(void) {
	StartTask(FollowEdge);
	for(;;) {
		if(isGrey()) {
			PlaySound(soundBlip);
			wait10Msec(10);
			if(isGrey()) {
				followingEdge = false;
				StopTask(FollowEdge);
				return FOUND_HOTEL;
			}
		 }
		abortTimeslice();
	}
}

int FollowSegmentTilEnd(void) {
	StartTask(FollowEdge);
	int forwards = gatherForwardsData();
	for(;;) {
		if(detectCan()) {
			followingEdge = false;
			StopTask(FollowEdge);
			return FOUND_CAN;
		}
		if(detectNode(forwards)) {
			if(isGrey()) {
				PlaySound(soundBlip);
				wait10Msec(10);
				if(isGrey()) {
					return FOUND_HOTEL;
				}
			  } else {
				followingEdge = false;
				StopTask(FollowEdge);
				return FOUND_NODE;
			}
		}

		abortTimeslice();
	}
	return FOUND_ERROR;

}
