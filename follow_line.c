#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "config.h"
#include "compass.c"
#include "light_sensor.c"
#include "map.c"

#define LEFT false
#define RIGHT true

#define SONAR_THRESHOLD 20
#define ANGLE_THRESHOLD 20

#define FOUND_ERROR -1
#define FOUND_CAN 1
#define FOUND_NODE 2
#define FOUND_HOTEL 4
#define FOUND_LEAF 8

bool followingEdge = true;

void displayBrightness(void) {
	string name;
	if(isGrey()) {
		name = "grey";
	} else if(isDark()) {
		name = "black";
	} else if(isLight()) {
		name = "white";
	}
	nxtDisplayCenteredTextLine(3, name);
 }

bool direction = LEFT;
int sweeps;
void edgeFollow(bool& running){
	sweeps = 0;
	if(direction == LEFT) {
		motor[left] = -SPEED;
		motor[right] = SPEED;
	} else {
		motor[left] = SPEED;
		motor[right] = -SPEED;
	}
	bool wasDark = isDark();
//displayBrightness();
	do{
	  if(direction) {
		  nxtDisplayCenteredTextLine(2, "RIGHT");
		} else {
		  nxtDisplayCenteredTextLine(2, "LEFT");
		}
		//Find border point
		if(wasDark != isDark()) {
			displayBrightness();
			wasDark = isDark();
			wait10Msec(10);
			if(direction == LEFT) {
				direction = RIGHT;
				motor[left] = SPEED;
				motor[right] = 0;
			} else if( direction == RIGHT) {
				direction = LEFT;
				motor[right] = SPEED;
				motor[left] = 0;
			}
			sweeps++;
			abortTimeslice();
		}
	}while(running);
}

bool detectCan(void) {
	return SensorValue[sonar] < SONAR_THRESHOLD;
}

bool detectNode(int forwards) {
	return abs(angleDifference(currentDirection(), forwards)) > ANGLE_THRESHOLD;
}

int gatherForwardsData(void) {
	time100[T2] = 0;
	int timeToWait = minDistance*10/(2*sweepSpeed);

	int count = 0;
	int forwards = 0;

	while(time100[T2] < timeToWait) {
		forwards = forwards + (angleDifference(currentDirection(), forwards))/++count;

		wait10Msec(20);
	}
	return forwards;
}

task FollowEdge(){
  if(!isDark()){
    PlaySound(soundException);
    wait10Msec(100);
    StopAllTasks();
  }
	followingEdge = true;
	edgeFollow(followingEdge);
}

bool checkIsLeaf(void) {
	int direction = currentDirection();
	while(!isDark()) {
		if( abs(angleDifference(currentDirection(), direction)) > 170) {
			return true;
		}
	}
	return false;
}

/**
 * Turns around until black is found
 */
void turnToLine(void) {
  int startDir = currentDirection();
  if(direction == LEFT) {
		motor[left] = -SPEED;
		motor[right] = SPEED;
	} else {
		motor[left] = SPEED;
		motor[right] = -SPEED;
	}

	while(!isDark()) {
		abortTimeslice();
	}
	motor[left] = 0;
	motor[right] = 0;
}

int FollowLineTilLeaf(void) {
	StartTask(FollowEdge);
	int forwards = gatherForwardsData();
	for(;;) {
		if(detectNode(forwards)) {
			if(checkIsLeaf()) {
				followingEdge = false;
				StopTask(FollowEdge);
				return FOUND_LEAF;
			} else {
				forwards = gatherForwardsData();
			}
		}
		abortTimeslice();
	}
}

int FollowLineTilHotel(void) {
	StartTask(FollowEdge);
	for(;;) {
		if(isGrey()) {
			PlaySound(soundBlip);
			wait10Msec(10);
			if(isGrey()) {
				followingEdge = false;
				StopTask(FollowEdge);
				return FOUND_HOTEL;
			}
		 }
		abortTimeslice();
	}
}
void faceForward(int forwards){
	if(angleDifference(currentDirection(), forwards) > 0){//too far to the right
		motor[left] = -SPEED; //turn left
	} else {
		motor[right] = -SPEED; //turn right
	}
	while(abs(angleDifference(currentDirection(), forwards)) > 1){
		wait1Msec(1);
	}

	int timeToWait = (sensorToAxle * 1000)/cruiseSpeed;
	time1[T3] = 0;
	motor[left] = SPEED;
	motor[right] = SPEED;

	while(time1[T3] < timeToWait) {
	  wait1Msec(1);
	};


	motor[left] = 0;
	motor[right] = 0;

}

int FollowSegmentTilEnd(Edge &edge) {
	StartTask(FollowEdge);
	int forwards = gatherForwardsData();
	edge.angle = forwards;

	int found = FOUND_ERROR;

	while(found == FOUND_ERROR) {
		if(detectCan()) {
			found = FOUND_CAN;
		}
		if(detectNode(forwards)) {
			found = FOUND_NODE;
		}

		abortTimeslice();
	}

	followingEdge = false;
	StopTask(FollowEdge);
	edge.length = sweeps;
	faceForward(forwards);

	return found;
}
