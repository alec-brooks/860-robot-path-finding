#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "config.h"
#include "compass.c"
#include "light_sensor.c"

#define CENTRE_THRESHOLD 5
#define SWEEP_ANGLE 15

#define LEFT false
#define RIGHT true

bool inSafetyZone(int centre, int threshold) {
  int max = (centre + threshold);
  int min = (centre - threshold);
  int dir = currentDirection();
  return dir <= max && dir >= min;
}

void FollowLineTilEnd(void) {
  //Find border point
  motor[left] = -SPEED;
  motor[right] = SPEED;
  bool wasDark = isDark();
  while (wasDark == isDark()) {
    abortTimeslice();
  }

  //Find centre angle
  int forwards = currentDirection();
  //Start sweeping
  bool expectDark = !wasDark;
  bool direction = LEFT;
  for(;;) {
    //Sweep&check til at x angle (or for x time)
    if(isDark() != expectDark) {
      if( inSafetyZone(forwards, CENTRE_THRESHOLD) ) {
      //Change expectation when light changes close to centre
        //Also adjust centre angle
       forwards = currentDirection();
       expectDark = isDark();
      } else {
        //Interrupt when light changes away from centre
        PlaySound(soundDownwardTones);
        motor[left] = 0;
        motor[right] = 0;
        return;
      }

      if( abs(currentDirection() - forwards) % 360 > SWEEP_ANGLE) {
        if(direction == LEFT) {
          direction = RIGHT;
          motor[left] = SPEED;
          motor[right] = -SPEED;
        } else {
          direction = LEFT;
          motor[right] = SPEED;
          motor[left] = -SPEED;
        }
      }
    }
    //Sweep other direction when x reached; repeat
  }
}

bool DetectCan(void) {
 return false;
}

int CountNodeEdges(void) {
  return 0;
}
