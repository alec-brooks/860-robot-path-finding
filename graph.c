#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNormal, PIDControl, encoder)

//*!!Code automatically generated by 'ROBOTC' configuration wizard

#include "types.h"
#include "config.h"
#include "compass.c"

void initGraph(Graph & graph){
    memset(graph.adjacency, 0, sizeof(Edge)*MAX_NODES*MAX_NODES);
    graph.nNodes = 0;
}

void addEdge(Graph & graph, int from, int to, Edge & edge){
    graph.adjacency[from][to] = edge;
    Edge reverse;
    reverse.length= edge.length;
    reverse.angle = angleDifference(edge.angle, 180);
    graph.adjacency[to][from] = reverse;
};

int addNode(Graph & graph){
    return graph.nNodes++;
}

int dijkstra(Graph & graph, int from, int to, Path & path){

    int nextStep = 0;
    int steps[MAX_NODES];

    //Initialise the set of known distances
    int distance[MAX_NODES];
    memset(distance, 0x7FFF, sizeof(int)*graph.nNodes); //Set unknown distances to a large number
    distance[from] = 0;

    //Initialise the set of nodes with unknown distance
    int unknownNodes[MAX_NODES];
    int remainingNodes = graph.nNodes;
    for(int i = 0; i < graph.nNodes; i++) {
        unknownNodes = i;
    }

    while( remainingNodes > 0 ) {
        //Find the unexplored node with the shortest known distance
        int minLength = 0x7FFF;
        int minNode = -1;
        int ix = -1;
        for(int i = 0; i < remainingNodes; i++) {
            if( distance[unknownNodes[ix]] < minLength ) {
                ix = i;
                minLength = distance[unknownNodes[ix]];
                minNode = unknownNodes[ix];
            }
        }
        remainingNodes--;
        //Remove the node from the list of unexplored nodes
        for(int i = ix; i < remainingNodes; i++) {
            unknownNodes[i] = unknownNodes[i+1];
        }

        //Check if accessible
        if(ix < 0) {
            //panic
        }
        //Iterate through intersections
        for(int i = 0; i < remainingNodes; i++) {
            Edge e = graph.adjacency[minNode][unknownNodes[i]];
            if( e.length > 0 ) {
                int pathCost = minLength + e.length
                if( pathCost < distance[unknownNodes[i]] ) {
                    distance[unknownNodes[i]] = pathCost;
                    steps[nextStep++] = e.angle;
                }
            }
        }
    }
    
    //Calculate the path from `to` back to `from`
    int stepCount = 0;
    for(int i = steps[to], stepCount = 0; i != from; i = steps[i], stepCount++) {
        path.angles[stepCount] = graph.adjacency[steps[i]][i].angle;
    }

    return nextStep;
}
