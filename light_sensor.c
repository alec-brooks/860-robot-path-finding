<<<<<<< HEAD
#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "config.h"


#define LIGHT_CALIB_FILE "lightCalib.dat"
int light_threshold = -1;
int dark_threshold = -1;
int greyValue;

void saveLightFile(int light_threshold, int dark_threshold){
  TFileHandle calibFile;
  TFileIOResult result;
  int size = 4;
  string name = "lightCalib.dat";
  Delete(name, result);
  OpenWrite(calibFile, result, name, size);
  WriteShort(calibFile, result, light_threshold);
  WriteShort(calibFile, result, dark_threshold);
  Close(calibFile, result);
}

void performLightCalibration(){
  motor[left] = SPIN_SPEED;
  motor[right] = -SPIN_SPEED;

  time100[T1] = 0;
  int maxLight = 0;
  int minLight = 101;
  while(time100[T1]<100){
    int value = SensorValue[light];
    if(value<minLight){
      minLight = value;
    }
    if(value>maxLight){
      maxLight = value;
    }
    wait10Msec(1);
  }
    motor[left] = 0;
    motor[right] = 0;

	//*
    light_threshold = maxLight - 5;
	  dark_threshold = minLight + 20;
	/*/
	light_threshold = ((maxLight + minLight)*2)/3;
	dark_threshold =  (maxLight + minLight)/3;
	//*/
	//light_threshold = (maxLight + minLight)/2;
	//dark_threshold = (maxLight + minLight)/2;
    saveLightFile(light_threshold, dark_threshold);
}

int getGreyvalue() {
 int count = 0;
 int a = 0;
	for(count = 0; count < 100; count++) {
	  a += SensorValue[light];
	  wait10Msec(1);
	}

	nxtDisplayBigTextLine(3, "%i", a/count);
	return a/count;
}

short readGreyValue() {
  TFileHandle calibFile;
  TFileIOResult result;
  int size = 2;
  string name = "greyCalib.dat";
  OpenRead(calibFile, result, name, size);
  short grey;
  ReadShort(calibFile, result, grey);
  Close(calibFile, result);
  return grey;
}

void readLightCalib() {
  string calibFileName = "lightCalib.dat";

  TFileHandle calibFile;
  TFileIOResult result;
  int size = 4;
  OpenRead(calibFile, result, calibFileName, size);
  ReadShort(calibFile, result, light_threshold);
  ReadShort(calibFile, result, dark_threshold);
  Close(calibFile, result);
}

void calibrateLight(){
  string calibFileName = "lightCalib.dat";

  TFileHandle calibFile;
  TFileIOResult result;
  int size = 4;
  FindFirstFile(calibFile, result, calibFileName, calibFileName, size);

  if(result==0){
    readLightCalib();
  } else{
    performLightCalibration();
  }
  greyValue = readGreyValue();
}

bool isDark(void) {
  nxtDisplayCenteredBigTextLine(2, "%i", SensorValue[light]);
  return SensorValue[light] <= dark_threshold;
}

bool isLight(void) {
  return SensorValue[light] >= light_threshold;
}

bool isGrey(void) {
  return abs(SensorValue[light] - greyValue) < 5;
}
=======
#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Motor,  motorB,          right,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "config.h"


#define LIGHT_CALIB_FILE "lightCalib.dat"
int light_threshold = -1;
int dark_threshold = -1;
int greyValue;

void saveLightFile(int light_threshold, int dark_threshold){
  TFileHandle calibFile;
  TFileIOResult result;
  int size = 4;
  string name = "lightCalib.dat";
  Delete(name, result);
  OpenWrite(calibFile, result, name, size);
  WriteShort(calibFile, result, light_threshold);
  WriteShort(calibFile, result, dark_threshold);
  Close(calibFile, result);
}

void performLightCalibration(){
  motor[left] = SPIN_SPEED;
  motor[right] = -SPIN_SPEED;

  time100[T1] = 0;
  int maxLight = 0;
  int minLight = 101;
  while(time100[T1]<100){
    int value = SensorValue[light];
    if(value<minLight){
      minLight = value;
    }
    if(value>maxLight){
      maxLight = value;
    }
    wait10Msec(1);
  }
    motor[left] = 0;
    motor[right] = 0;

	//*
    light_threshold = maxLight - 5;
	  dark_threshold = minLight + 20;
	/*/
	light_threshold = ((maxLight + minLight)*2)/3;
	dark_threshold =  (maxLight + minLight)/3;
	//*/
	//light_threshold = (maxLight + minLight)/2;
	//dark_threshold = (maxLight + minLight)/2;
    saveLightFile(light_threshold, dark_threshold);
}

int getGreyvalue() {
 int count = 0;
 int a = 0;
	for(count = 0; count < 100; count++) {
	  a += SensorValue[light];
	  wait10Msec(1);
	}

	nxtDisplayBigTextLine(3, "%i", a/count);
	return a/count;
}

short readGreyValue() {
  TFileHandle calibFile;
  TFileIOResult result;
  int size = 2;
  string name = "greyCalib.dat";
  OpenRead(calibFile, result, name, size);
  short grey;
  ReadShort(calibFile, result, grey);
  Close(calibFile, result);
  return grey;
}

void readLightCalib() {
  string calibFileName = "lightCalib.dat";

  TFileHandle calibFile;
  TFileIOResult result;
  int size = 4;
  OpenRead(calibFile, result, calibFileName, size);
  ReadShort(calibFile, result, light_threshold);
  ReadShort(calibFile, result, dark_threshold);
  Close(calibFile, result);
}

void calibrateLight(){
  string calibFileName = "lightCalib.dat";

  TFileHandle calibFile;
  TFileIOResult result;
  int size = 4;
  FindFirstFile(calibFile, result, calibFileName, calibFileName, size);

  if(result==0){
    readLightCalib();
  } else{
    performLightCalibration();
  }
  greyValue = readGreyValue();
}

bool isDark(void) {
  nxtDisplayCenteredBigTextLine(2, "%i", SensorValue[light]);
  return SensorValue[light] <= dark_threshold;
}

bool isLight(void) {
  return SensorValue[light] >= light_threshold;
}

bool isGrey(void) {
  return abs(SensorValue[light] - greyValue) < 5;
}
>>>>>>> 16a7e5657e89aca3b6604cf288755a9fa1eb314d
